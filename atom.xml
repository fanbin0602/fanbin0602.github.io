<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.fanbin.dev</id>
    <title>MQ LOG</title>
    <updated>2019-11-15T03:26:33.555Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.fanbin.dev"/>
    <link rel="self" href="https://blog.fanbin.dev/atom.xml"/>
    <subtitle>&lt;span style=&apos;color:lightgrey;font-size:12px&apos;&gt;/* MQ is short for 懵圈儿 */&lt;/span&gt;</subtitle>
    <logo>https://blog.fanbin.dev/images/avatar.png</logo>
    <icon>https://blog.fanbin.dev/favicon.ico</icon>
    <rights>All rights reserved 2019, MQ LOG</rights>
    <entry>
        <title type="html"><![CDATA[感冒这件小事儿]]></title>
        <id>https://blog.fanbin.dev/post/c-vBEril7</id>
        <link href="https://blog.fanbin.dev/post/c-vBEril7">
        </link>
        <updated>2019-11-14T11:46:10.000Z</updated>
        <summary type="html"><![CDATA[<p>天气又开始变冷变干了，又到了容易感冒的季节，正好读了卓克的一篇关于感冒的文章，了解到了一些跟感冒有关的以前不知道的事儿，分享一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>天气又开始变冷变干了，又到了容易感冒的季节，正好读了卓克的一篇关于感冒的文章，了解到了一些跟感冒有关的以前不知道的事儿，分享一下。</p>
<!-- more -->
<h3 id="感冒到底是啥">感冒到底是啥？</h3>
<p>感冒其实是病毒在鼻粘膜上繁殖引起的病症，主要分为两类：</p>
<ul>
<li>普通感冒</li>
<li>流行性感冒</li>
</ul>
<p>划分的标准就是要看是什么病毒引起的感冒，只要不是流感病毒引起的，都算是普通感冒。之所以要把流行性感冒和其他的普通感冒区分开，是因为流感的症状比较严重，而且流感病毒有一种特定结构，可以单独防治，算是一种特殊的感冒。而普通感冒的病毒有数百种之多。</p>
<h3 id="怎么预防感冒">怎么预防感冒？</h3>
<p>第一，减少抠鼻子和摸眼睛。所有公共场合的用品，上面落有普通感冒病毒的概率是 50%，它们被粘在手上平均可以停留两个小时。手上沾了感冒病毒后，如果用手抠鼻子，就相当于直接把病毒带到了鼻粘膜上，如果用手揉眼睛，眼睛中有泪管，跟鼻子是通着的，病毒就会顺着泪管感染到鼻粘膜上。这都会引起感冒。</p>
<p>第二，勤洗手。有时候抠鼻子和揉眼睛是不可避免的，所以勤洗手就很重要。据统计，如果经常认真洗手，一年中感冒的次数可以减半。</p>
<p>第三，戴口罩。主要是在人多聚集的地方，戴口罩可以有效防范感冒病毒的传递。</p>
<p>总之，就是要降低病毒进入鼻腔的可能性。</p>
<h3 id="我们和感冒之间的误会">我们和感冒之间的误会</h3>
<p>第一，着凉了、冻着了，会感冒吗？它们和感冒之间没有因果关系。入秋之后，空气干燥，风大，有利于病毒飞入鼻腔，引起感冒。刮风、降温只是总跟感冒一起出现，但并不存在因果关系。</p>
<p>第二，增强抵抗力会不容易感冒吗？不会。抵抗力越强的人，杀起病毒来越迅猛，因此感冒症状会越剧烈。头疼、鼻涕、发烧，这些都是身体杀灭病毒的措施，而并不是病毒伤害身体的手段。</p>
<p>第三：抗生素能防止感冒吗？不能。抗生素是对付细菌的。</p>
<h3 id="感冒了到底该怎么办">感冒了到底该怎么办？</h3>
<p>普通人得了普通感冒，多喝水、多休息就行了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyCat 读写分离配置]]></title>
        <id>https://blog.fanbin.dev/post/PNJ5aPHVl</id>
        <link href="https://blog.fanbin.dev/post/PNJ5aPHVl">
        </link>
        <updated>2019-09-07T07:51:47.000Z</updated>
        <summary type="html"><![CDATA[<p>这篇是基于<a href="/post/Qg_Mg199T/">另一篇</a>当中 MySQL 主从复制的示例，来用 MyCat 作为数据库中间件，实现只对外暴露一个数据库连接入口的 MySQL 读写分离。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这篇是基于<a href="/post/Qg_Mg199T/">另一篇</a>当中 MySQL 主从复制的示例，来用 MyCat 作为数据库中间件，实现只对外暴露一个数据库连接入口的 MySQL 读写分离。</p>
<!-- more -->
<h2 id="0-前提">0. 前提</h2>
<ol>
<li>完成 MySQL 主从复制的部署（<a href="/post/Qg_Mg199T/">传送门</a>）。</li>
<li>还是基于 Docker，运行一个 MyCat 容器。</li>
<li>应该就这些。</li>
</ol>
<h2 id="1-mycat-容器部署">1. MyCat 容器部署</h2>
<p>首先，下载 MyCat。由于我们要不输在容器里，所以下载 Linux 的版本。</p>
<pre><code class="language-bash">$ wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz
</code></pre>
<p>此时，得到一个 <code>Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz</code> 文件。为了方便后面使用，给它改个名字。</p>
<pre><code class="language-bash">$ mv Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz mycat.tar.gz
</code></pre>
<p>在当前目录解压它，并把其中的 <code>conf</code> 目录拷贝一份，供 Docker 容器挂载，这样就不需要进入到容器里面修改 MyCat 的配置。</p>
<pre><code class="language-bash">$ tar -zxvf mycat.tar.gz
$ cp -r mycat/conf/ conf/
</code></pre>
<p>准备工作完成后，开始构建容器镜像，创建一个 Dockerfile，在其中写入以下内容：</p>
<pre><code>FROM openjdk:8
ADD mycat.tar.gz /usr/local/
VOLUME /usr/local/mycat/conf
ENV MYCAT_HOME=/usr/local/mycat
EXPOSE 8066 9066
CMD [&quot;/usr/local/mycat/bin/mycat&quot;,&quot;console&quot;,&quot;&amp;&quot;]
</code></pre>
<p>逐行解释一下 Dockerfile 的内容：</p>
<ol>
<li>MyCat 基于 Java，因此使用 <code>openjdk:8</code> 镜像构建我们使用的 MyCat 镜像。</li>
<li>将下载并重命名好的 <code>mycat.tar.gz</code> 添加到容器的 <code>/usr/local/</code> 目录。</li>
<li>将 MyCat 的配置文件目录 <code>/usr/local/mycat/conf</code> 暴露给宿主机，启动时直接映射之前宿主机上复制好的 <code>conf</code> 目录。</li>
<li>设置环境变量 <code>MYCAT_HOME</code>，值是 MyCat 的安装目录。</li>
<li>暴露 8066 和 9066 两个端口。8066 端口用于外部连接数据库，类似于 MySQL 的 3306 端口；9066 是 MyCat 的管理端口。</li>
<li>执行启动 MyCat 的命令。</li>
</ol>
<p>在当前目录构建镜像：</p>
<pre><code class="language-bash">$ docker build -t mycat-1.6.7.1 .
</code></pre>
<p>然后启动一个容器实例：</p>
<pre><code class="language-bash">$ docker run --name mycat -p 8066:8066 -p 9066:9066 -v /path/to/conf/:/usr/local/mycat/conf/ -d mycat-1.6.7.1 --link mysql-dn-s:mysql-slave --link mysql-dn-m:mysql-master 
</code></pre>
<p>注：以上命令中的 <code>/path/to/conf/</code> 指的是实际宿主机中 <code>conf</code>目录的绝对路径。同时，用 <code>--link</code> 创建了与两个数据库之间的网络连接。</p>
<p>现在 MyCat 的容器已经跑起来了，但是在配置好数据源之前还不能用。</p>
<h2 id="2-修改-mycat-配置">2. 修改 MyCat 配置</h2>
<p>因为之前启动容器的时候做了配置文件目录的映射，所以我们直接在宿主机的 <code>conf</code> 目录中修改 MyCat 的配置。</p>
<p>首先修改 <code>schema.xml</code>，主要内容如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;
&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;

	&lt;!-- MyCat 对外暴露的 schema --&gt;
	&lt;schema name=&quot;test&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;
	&lt;/schema&gt;
	
	&lt;!-- 数据节点，这里我们只配置读写分离的部分，因此只配置一个节点来做读写分离的示例 --&gt;
	&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;test&quot; /&gt;
	
	&lt;!-- 这里的 balance=1 表示配置读写分离--&gt;
	&lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;
			  writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;
		&lt;!--心跳通知的查询语句，使用默认即可--&gt;
		&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;
		&lt;!--写库配置--&gt;
		&lt;writeHost host=&quot;hostM&quot; url=&quot;mysql-master:3306&quot; user=&quot;root&quot; password=&quot;admin123&quot;&gt;
			&lt;!--读库配置--&gt;
			&lt;readHost host=&quot;hostS&quot; url=&quot;mysql-slave:3306&quot; user=&quot;root&quot; password=&quot;admin123&quot; /&gt;
		&lt;/writeHost&gt;
	&lt;/dataHost&gt;
	
&lt;/mycat:schema&gt;
</code></pre>
<p>因为本示例只演示读写分离，不涉及分区分片等配置，因此这个配置文件很简单。</p>
<p>下面配置 <code>server.xml</code>，只需打开文件，添加一个 MyCat 的外部访问用户即可，也可配置多个，视具体情况而定：</p>
<pre><code class="language-xml">&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;
		&lt;property name=&quot;password&quot;&gt;admin123&lt;/property&gt;
		&lt;property name=&quot;schemas&quot;&gt;test&lt;/property&gt;
&lt;/user&gt;
</code></pre>
<p>以上作为演示，只配置了基本的用户名、密码和库，实际情况中，还可以配置读写权限，甚至是表级 DML 权限，具体可以查阅官方文档。</p>
<p>配置好后，重启容器生效。</p>
<h2 id="3-测试验证">3. 测试验证</h2>
<p>使用与连接 MySQL 同样的方法，在宿主机上连接 MyCat：</p>
<pre><code class="language-bash">$ mycli -hlocalhost -P8066 -uroot -padmin123
</code></pre>
<p>注：如果连接不成功，可能需要修改两台 MySQL 的用户认证配置：<code>ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'admin123';</code>。</p>
<p>连接成功后，就可以像直接操作 MySQL 一样进行数据库操作了。</p>
<h2 id="4-测试读写分离">4. 测试读写分离</h2>
<p>在测试读写分离时，需要查看 MyCat 的日志来确定每此操作是在哪个数据库执行的，因此，首先需要修改以下 MyCat 的日志配置文件，来让 MyCat 把这部分日志打印出来。</p>
<p>在 <code>conf</code> 目录的 <code>log4j2.xml</code> 文件中，修改如下内容：</p>
<pre><code class="language-xml">&lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;
</code></pre>
<p>将其中的日志级别设置为 <code>debug</code>，修改保存后重启 MyCat 容器。</p>
<p>现在，进入 MyCat 容器中，使用如下命令，实时查看日志：</p>
<pre><code class="language-bash">$ tail -f /usr/local/mycat/logs/mycat.log
</code></pre>
<p>不要关闭查看日志的窗口，另起一个终端，连接 MyCat 对数据进行操作，在日志中就可以看到每一步操作的 SQL 语句，以及对应的更多信息。</p>
<p>比如下面两条日志：</p>
<pre><code class="language-bash">2019-09-07 08:46:42.628 DEBUG [$_NIOREACTOR-5-RW] (io.mycat.server.NonBlockingSession.releaseConnection(NonBlockingSession.java:386)) - release connection MySQLConnection [id=14, lastTime=1567846002623, user=root, schema=test, old shema=test, borrowed=true, fromSlaveDB=true, threadId=380, charset=utf8, txIsolation=3, autocommit=true, attachment=dn1{select * from test}, respHandler=SingleNodeHandler [node=dn1{select * from test}, packetId=9], host=mysql-slave, port=3306, statusSync=io.mycat.backend.mysql.nio.MySQLConnection$StatusSync@230d92a6, writeQueue=0, modifiedSQLExecuted=false]
</code></pre>
<pre><code class="language-bash">2019-09-07 08:48:23.387 DEBUG [$_NIOREACTOR-5-RW] (io.mycat.server.NonBlockingSession.releaseConnection(NonBlockingSession.java:386)) - release connection MySQLConnection [id=5, lastTime=1567846103379, user=root, schema=test, old shema=test, borrowed=true, fromSlaveDB=false, threadId=587, charset=utf8, txIsolation=3, autocommit=true, attachment=dn1{insert into test(value) values(15)}, respHandler=SingleNodeHandler [node=dn1{insert into test(value) values(15)}, packetId=1], host=mysql-master, port=3306, statusSync=null, writeQueue=0, modifiedSQLExecuted=true]
</code></pre>
<p>从这两条日志中可以看出 MyCat 在读库执行了查询操作，并在写库执行了插入操作。</p>
<p>👍</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 主从复制]]></title>
        <id>https://blog.fanbin.dev/post/Qg_Mg199T</id>
        <link href="https://blog.fanbin.dev/post/Qg_Mg199T">
        </link>
        <updated>2019-09-07T01:31:11.000Z</updated>
        <summary type="html"><![CDATA[<p>本文演示一个简单的 MySQL 主从复制的示例。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文演示一个简单的 MySQL 主从复制的示例。</p>
<!-- more -->
<h2 id="0-说明">0. 说明</h2>
<ol>
<li>本示例为一主一从的架构。</li>
<li>使用 Docker 启动两个 MySQL 容器来做演示，确保已经安装了 Docker，并且懂得 Docker 的基本用法。</li>
</ol>
<h2 id="1-创建并启动容器">1. 创建并启动容器</h2>
<p>主库：</p>
<pre><code class="language-bash">docker run --name=mysql-dn-m  --env=MYSQL_ROOT_PASSWORD=admin123 -p 3316:3306 -p 33160:33060  -d mysql:latest
</code></pre>
<p>从库</p>
<pre><code class="language-bash">docker run --name=mysql-dn-s --env=MYSQL_ROOT_PASSWORD=admin123 -p 3326:3306 -p 33260:33060 --link mysql-dn-m:master -d mysql:latest
</code></pre>
<p>以上操作的说明：</p>
<ol>
<li>启动两个 MySQL 容器（镜像的具体信息可以在<a href="https://hub.docker.com/_/mysql">这里</a>查看），主库容器命名为 <code>mysql-dn-m</code>，从库容器命名为 <code>mysql-dn-s</code>。</li>
<li>设置 <code>root</code> 用户的密码为 <code>admin123</code>（只作为演示实用）。</li>
<li>映射相应的端口号。</li>
<li>在从库容器创建时，使用 <code>--link mysql-dn-m:master</code> 创建从库容器到主库容器的网络连接，这样可以在从库内以 <code>master</code> 为主机名，访问主库。</li>
</ol>
<p>使用 <code>docker ps</code> 命令，查看当前正在运行的容器，保证以上操作正常。</p>
<h2 id="1-主库配置">1. 主库配置</h2>
<p>使用 <code>docker exec -it mysql-dn-m /bin/bash</code> 命令进入主库容器的命令行。编辑 <code>/etc/mysql/my.cnf</code> 配置文件。</p>
<p>首先，在 <code>[mysqld]</code> 的下方，添加一下配置（# 符号后面的内容为注释）：</p>
<pre><code>log-bin=mysql-bin # 开启二进制日志
server-id=1 # 设置唯一的 server-id
</code></pre>
<p>然后在配置文件的最后添加如下内容：</p>
<pre><code>binlog-ignore-db=mysql
binlog-ignore-db=information_schema
binlog-ignore-db=performance_schema
binlog-ignore-db=sys
</code></pre>
<p>这样可以忽略复制 MySQL 内置的四个数据库。</p>
<p>如果需要自定义复制的库，可以用 <code>binlog-do-db</code> 参数来配置，不配置的话，默认复制所有库。</p>
<p>操作完以后重启主库容器。</p>
<p>可以连接主库，执行一下 SQL 语句，查看日志的开启状态。</p>
<pre><code class="language-sql">show variables like '%log_bin%';
</code></pre>
<p>如果 <code>log_bin</code> 的值是 <code>ON</code>，则表示没有问题。</p>
<h2 id="2-从库配置">2. 从库配置</h2>
<p>使用与主库同样的方法，编辑从库容器中的 <code>/etc/mysql/my.cnf</code> 配置文件。从库的配置只需要在 <code>[mysqld]</code> 的下方添加一行即可：</p>
<pre><code>server-id=2 # 设置唯一的 server-id
</code></pre>
<p>操作完以后重启从库容器。</p>
<h2 id="3-在主库创建用与数据同步的用户账号">3. 在主库创建用与数据同步的用户账号</h2>
<p>进入主库。</p>
<p>执行如下命令创建用户，用户名、主机、密码按需设置，然后记住：</p>
<pre><code class="language-sql">CREATE USER 'repl'@'%' IDENTIFIED BY 'slavepass';
</code></pre>
<p>然后，为刚刚创建的用户授权：</p>
<pre><code class="language-sql">GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'
</code></pre>
<p>最后刷新权限：</p>
<pre><code class="language-sql">flush privileges;
</code></pre>
<p>完成后，可以使用下面的查询语句来验证这一步的操作：</p>
<pre><code class="language-sql">show grants for 'repl';
</code></pre>
<h2 id="4-配置主从复制">4. 配置主从复制</h2>
<p>先连接主库，执行一下查询操作：</p>
<pre><code class="language-sql">show master status\G;
</code></pre>
<p>查询结果类似以下内容：</p>
<pre><code>***************************[ 1. row ]***************************
File              | mysql-bin.000009
Position          | 435
Binlog_Do_DB      |
Binlog_Ignore_DB  | mysql,information_schema,performance_schema,sys
Executed_Gtid_Set |
</code></pre>
<p>记下 <code>File</code> 和 <code>Position</code> 的值。</p>
<p>连接从库，使用之前创建的用户，和刚刚记下的两个值，执行以下操作来创建复制：</p>
<pre><code class="language-sql">change master to MASTER_HOST = 'master', MASTER_PORT = 3306, MASTER_USER = 'repl', MASTER_PASSWORD = 'slavepass', MASTER_LOG_FILE = 'mysql-bin.000009', MASTER_LOG_POS = 435;
</code></pre>
<p>参数说明：</p>
<ol>
<li>MASTER_HOST：主库的主机，可以是 IP 或者主机名，这里输入我们之前配置的 <code>master</code>。</li>
<li>MASTER_PORT：主库的端口号，使用默认端口号时可以省略这个参数。</li>
<li>MASTER_USER：之前配置的用于复制的用户名。</li>
<li>MASTER_PASSWORD：之前配置的用于配置的用户密码。</li>
<li>MASTER_LOG_FILE：之前记下的主库日志文件名。</li>
<li>MASTER_LOG_POS：之前记下的主库日志位置。</li>
</ol>
<p>执行以上语句后，就创建成功了。可以在从库上执行以下查询语句验证主从复制的状态：</p>
<pre><code class="language-sql">show slave status\G;
</code></pre>
<p>如果 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 两项的值都是 <code>Yes</code> 就说明成功了。</p>
<p>如果没有成功，查询结果中的相应字段也会给出失败的信息，供排查错误。我在配置的过程中遇到了 <code>Authentication plugin 'caching_sha2_password' reported error: Authentication requires secure connection</code> 的错误，通过 Google 搜索，在主库执行了 <code>ALTER USER 'repl'@'%' IDENTIFIED WITH mysql_native_password BY 'slavepass';</code> 语句解决了问题，这个应该是验证方式不匹配导致从库连接主库失败。</p>
<p>其他导致连接不成功的错误还包括容器之间网络不通、用户名密码或者权限配置错误、日志文件和位置配置错误等，出错时可以排查一下这些内容。</p>
<h2 id="5-测试验证">5. 测试验证</h2>
<p>至此就配置完成了，可以在主库创建数据库、表，或者插入、修改、删除数据来验证配置是否成功。</p>
<h2 id="6-如果一个数据库挂掉了怎么办">6. 如果一个数据库挂掉了怎么办？</h2>
<p>如果从库挂掉了，主库内容发生了变化，在从库再次启动后，会自动同步期间发生变化的数据。</p>
<p>在此主要说明一下主库挂掉以后，怎样重新建立数据同步。</p>
<p>首先，重新查看主库日志文件和位置：<code>show master status\G</code>。</p>
<p>然后在从库执行如下步骤：</p>
<ol>
<li>停止复制：<code>stop slave</code>。</li>
<li>重新配置主从复制的参数：<code>change master to MASTER_HOST = 'master', MASTER_PORT = 3306, MASTER_USER = 'repl', MASTER_PASSWORD = 'slavepass', MASTER_LOG_FILE = 'mysql-bin.000009', MASTER_LOG_POS = 435;</code></li>
<li>启动复制：<code>start slave;</code>。</li>
</ol>
<hr>
<p>立 FLAG：</p>
<ul>
<li>🚩研究一下前面提到的用户认证出问题的原理。</li>
<li>🚩研究主从复制的更多细节问题。</li>
<li>🚩写篇 Docker 入门的文。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组和二分查找]]></title>
        <id>https://blog.fanbin.dev/post/3UuCV633y</id>
        <link href="https://blog.fanbin.dev/post/3UuCV633y">
        </link>
        <updated>2019-07-24T14:20:54.000Z</updated>
        <summary type="html"><![CDATA[<p>这篇总结一下数组和二分查找算法。数组是计算机科学中最基础的数据结构，二分查找算法是一种最简单却有趣的算法。它们是走进算法世界最先接触的东西。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这篇总结一下数组和二分查找算法。数组是计算机科学中最基础的数据结构，二分查找算法是一种最简单却有趣的算法。它们是走进算法世界最先接触的东西。</p>
<!-- more -->
<h2 id="数组">数组</h2>
<h3 id="数组是什么">数组是什么</h3>
<p>数据结构是计算机程序组织和存储数据的方式，数组是计算机科学中最基本的数据结构之一。它通常是由相同类型的元素组成，类似于一个列表，比如待办清单、产品目录等。</p>
<p>比如：</p>
<pre><code class="language-python">products = [&quot;Mac&quot;, &quot;iPad&quot;, &quot;iPhone&quot;, &quot;Watch&quot;, &quot;iPod&quot;]
</code></pre>
<p>这个产品列表就是一个包含五个元素的数组，每个元素是一个产品名称。</p>
<h3 id="数组在内存中是怎么保存的">数组在内存中是怎么保存的</h3>
<p>计算机在内存中，会分配若干个连续的内存单元来存储数组。可以把内存看作超市门口的储物柜，储物柜的每个格子就是一个内存单元，有些格子放了东西，有些格子是空的。当计算机需要存储这个五个元素的数组时，就需要在这个储物柜中找出五个连续排列的空格子，把数组中的五个元素按顺序放进去。</p>
<figure data-type="image" tabindex="1"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/1.png" alt=""></figure>
<h3 id="在数组中读取元素">在数组中读取元素</h3>
<p>数组中元素顺序都是不变的，因此它们有一个天然的属性——索引，也可以理解为元素的序号，一般是从 0 开始，第一个元素的索引是 0，第二个元素的索引是 1，以此类推。计算机程序只需要知道存储数组的内存地址，也就是数组中第一个元素的内存地址，就可以根据每个元素的索引，计算出任何元素的内存地址，从而快速找到它们。</p>
<p>如下图：</p>
<figure data-type="image" tabindex="2"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/2.png" alt=""></figure>
<p>灰色的格子表示已经被占用的内存（想象这是一个储物柜，有一些储物格子已经放了东西），我们要存储的数组元素被放在五个连续的原先空着的格子里。</p>
<p>内存的每个格子都有一个地址，为了描述简单，我们假设这些格子的内存地址分别是1000、1001、1002……，因此我们保存的五个数组元素的内存地址就是1010、1011、1012、1012、1014。数组本身会记有第一个格子的内存地址，这样计算机可以一步就访问到任意一个内存地址的数据。因此，数组中任意一个元素的内存地址，就是第一个格子的内存地址，加上元素的索引。比如，计算机要访问第三个元素“iPhone”，就可以直接访问地址是1012（第一个元素的地址1010，加第三个元素的下标2）的内存格子，得到字符串“iPhone”。</p>
<p>因此，读取数组中一个元素，只需要一步操作，记为 <code>O(1)</code>。</p>
<p>这种表示方法，称为大O记法，用来表示算法执行的速度（也称复杂度）。这个速度并不按时间计算，而是按操作步数计算。衡量操作时间需要考虑硬件条件，衡量步数才是分析速度的关键。</p>
<h3 id="在数组中查找元素">在数组中查找元素</h3>
<p>查找操作与读取操作正好相反，读取操作是已知元素的索引，去内存中获取它的值。而查找操作是给定一个值，检查数组中是否包含这个值，以及它在数组中的什么位置。</p>
<p>查找元素最直接的方式，就是按顺序轮流读取数组中的每个元素，看是不是我们要找的那一个，当找到的时候，就知道了它在数组中的位置，也就是元素的索引下标，如果数组中所有的元素都不是我们要找的，那它就不在这个数组中。</p>
<figure data-type="image" tabindex="3"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/3.png" alt=""></figure>
<p>以上就是一个数组中查找元素的<strong>算法</strong>，它的名字叫线性查找。如果我们要分析这个算法的执行速度，就需要知道这个算法要执行多少步操作。在最坏的情况下，比如，我们要找的元素在数组的末尾，或者不在数组中，那么，在一个长度为 N 的数组中查找元素需要执行 N 步操作。复杂度记为<code>O(n)</code>。</p>
<p>从上面的描述中可以看出，线性查找算法显然是一个很笨的方法，那有没有聪明一点的方法呢？</p>
<h2 id="二分查找">二分查找</h2>
<h3 id="什么是二分查找">什么是二分查找</h3>
<p>之前说过，<strong>数据结构服务于算法，算法运行与数据结构之上</strong>，为了对数组执行快速查找元素的算法，需要引入新的数据结构有序数组——元素在数组中始终保持有序。比如，从大到小的一组数字，或按字母顺序排列的一组名称等。</p>
<p>有了这样的数据结构，我们就有更聪明的查找算法。设想，你要在一本书里找一篇文章，从目录中得知这篇文章在第261页，你怎么找到第261页呢？一本书就是一个数组，书里的每一页是数组中的一个元素，我们要找到值为261的元素，按照之前介绍的线性查找的办法，我们需要从第1页开始找，一直找到261页——你一定不会这么做。</p>
<p>以下才是大多数人的做法：因为书籍中每一页的页码是按顺序排列的，因此它是一个有序数组。你会先从中间部分随便翻到一页，如果这一页的页码比 261 大，你就会在这页之前的部分再随便翻一页，反之，在它之后随意翻一页。以此类推，直到找到第 261 页。</p>
<p>在一个有序的数组中查找元素，同样可以用这个方法。这种算法叫「二分查找」。</p>
<h3 id="二分查找的步骤">二分查找的步骤</h3>
<p>之所以叫二分查找，是因为，这个算法的步骤是，取数组中间的一个值，这样数组就会被分成两部分，根据中间的值与查找目标值的大小对比（也可以是字母顺序对比，或者其他方法对比，具体依数组内元素的排序方法而定），来选取中间值之前或之后的那部分，再进行相同的操作，直到找到目标值。</p>
<figure data-type="image" tabindex="4"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/4.2.png" alt=""></figure>
<p>使用二分查找算法的好处是，能用更快的速度，也就是更少的操作步骤找到目标值。例如在一个长度为 100 的有序数组中，使用线性查找算法，最多需要操作 100 步，而使用二分查找算法，最多只需要 7 步，二分查找算法的时间复杂度是 <code>O(log n)</code>。</p>
<p>下图是随着元素数量的增加，两种复杂度的算法需要执行操作的步数对比。横轴是操作的元素数量，纵轴是算法需要执行的操作步数。可见，随着元素数量增加，两者的差距会越来越大。</p>
<figure data-type="image" tabindex="5"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/5.png" alt=""></figure>
<h3 id="算法复杂度的表示">算法复杂度的表示</h3>
<p>关于算法时间复杂度，除了上面介绍的两种，常见的还有 <code>O(n)</code>、<code>O(n*log n)</code>、<code>O(n^2)</code>、<code>O(n!)</code>等，算法的复杂度本质上指的是，随着操作元素的增加，算法需要执行的步数的增速。如果一个数组中只有一个元素，那线性查找和二分查找的执行步骤是一样多的。但是随着元素数量的增加，线性查找的操作步数呈线性增长，而二分查找的操作步数呈对数增长，两者差距很大。</p>
<figure data-type="image" tabindex="6"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/3UuCV633y/6.png" alt=""></figure>
<h2 id="总结和预告">总结和预告</h2>
<p>这篇介绍了最基本的数据结构——数组，以及最简单却有趣的算法——二分查找，顺便了解了使用大O记法表示算法的时间复杂度。总结如下：</p>
<ol>
<li>数组是一个线性排列的数据元素集合，存储在连续的内存空间中。</li>
<li>计算机从数组中读取任意元素，只需操作1步，复杂度是 <code>O(1)</code>。</li>
<li>在数组中通过线性查找的方法查找一个元素的复杂度是<code>O(n)</code>。</li>
<li>在有序数组中查找元素，可以使用二分查找算法，复杂度是 <code>O(log n)</code>。</li>
<li>算法复杂度一般用大O记法表示，它表现的是随着操作元素的增加，执行算法需要进行的操作步数的增速。</li>
</ol>
<p>后面会分析数组的另外两个操作：插入元素和删除元素，并且会引入新的数据结构——链表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从数据结构和算法说起]]></title>
        <id>https://blog.fanbin.dev/post/KjvN5t32S</id>
        <link href="https://blog.fanbin.dev/post/KjvN5t32S">
        </link>
        <updated>2019-07-18T16:01:50.000Z</updated>
        <summary type="html"><![CDATA[<p>之前的一个月，是我裸辞以后找工作的时间。出于自己的上进心，以及面试官对我的「虐待」，我开始认真复习了一些数据结构和算法的知识。有了新的收获，做一些记录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前的一个月，是我裸辞以后找工作的时间。出于自己的上进心，以及面试官对我的「虐待」，我开始认真复习了一些数据结构和算法的知识。有了新的收获，做一些记录。</p>
<!-- more --> 
<p>在大学的时候，数据结构和算法、计算机网络、操作系统、编译原理这些课程，让很多人头疼，而且，很多知识由于在学校里缺乏实践，学过考过之后很快就忘掉了。刚开始工作时，大部分人的工作内容也很少涉及到这些知识，于是它们就被大部分人忘记了。但是，这些并不是没用的知识，而是一些「不懂也感觉不到有什么坏处，但搞懂后就大不一样」的知识。</p>
<h2 id="它们到底是什么">它们到底是什么</h2>
<p>数据结构是计算机存储和组织数据的方式，我们常见的数据结构，数组、链表、散列表等，都是对一组数据的不同组织方式。算法是指计算机程序操作数据的步骤，比如常见的快速排序、二分查找等。</p>
<h2 id="为什么要学习这些知识">为什么要学习这些知识</h2>
<p><strong>数据结构</strong>是计算机组织和存储一组数据的方式。最常见的数据结构有数组、链表、散列表、二叉树等等。</p>
<p>随着计算机程序处理数据量的增加，不同的数据结构对一组数据的组织方式，会对程序的运行性能产生巨大影响。</p>
<p><strong>算法</strong>是计算机程序操作数据的具体步骤。</p>
<p>举个例子，要把大象装冰箱，总共分三步：</p>
<ol>
<li>把冰箱门打开</li>
<li>把大象放进去</li>
<li>把冰箱门关上</li>
</ol>
<p>以上就是把大象装冰箱的一种「算法」，之所以说是「一种」算法，是因为，计算机程序做一件事，可以使用任何能够达到计算目标的算法。但是，不同的算法在做同一件事情的时候，代码和运行速度和资源消耗，有不小的差别，这也是为什么我们要学习算法的知识。</p>
<p>数据结构和算法两者经常被一起提及，是因为在实际应用中，它们密不可分。</p>
<p><strong>数据结构服务于算法，算法运行在特定的数据结构之上。</strong></p>
<p>不要小看它们对代码性能和资源消耗的影响，很多流行的开源项目，它们的优秀之处，除了巧妙的架构设计，很大程度上都得益于高性能和低消耗，很多编程高手，它们的优秀之处很大程度上也在于能写出这样的代码。</p>
<h2 id="为什么要学好数据结构和算法">为什么要学好数据结构和算法</h2>
<p>对于需要去找工作的程序员来说，学习数据结构和算法知识，最直接的好处就是通过面试。大部分的 技术面试中都会问到一些相关的知识，比如快速排序、二叉树操作等。</p>
<p>在工作中，不懂数据结构和算法的程序员，几乎只能写一些基本的业务代码，做一名倔强的 CRUD boy，很难跨过初级程序员的第一个职业台阶。掌握这些底层的知识，能让一个初级程序员从业务开发向系统架构逐步转变。</p>
<p>除了跨越职业发展门槛这件事，认真学习这些基础知识，更能带来思维的转化。有些人是科班出身，但是大学时候并没有认真学习基础课程，有些人不是科班出身，学习了一些开发框架的使用，就能开始程序员的职业生涯，对于这些人，基础知识迟早是要补的。</p>
<p>如果能熟练的掌握和运用数据结构和算法的相关知识，就能在平时写代码的过程中，去关注代码的质量、运行性能、扩展性等问题，而不是关注能不能完成功能的问题。这一定是一个重要的转变。</p>
<p>另外，如果想写一个开源项目，学习和运用合适的数据结构和算法，也能让代码更拿得出手。</p>
<h2 id="还有什么好处">还有什么好处</h2>
<p>除了关注点的转变（从表层到底层）和思维方式的转变（从功能到性能），基础知识的学习也能带来一些长期的好处。</p>
<p>近些年，前端开发领域发展迅速，各种新的开发框架 层出不穷，很多人盲目地追求新技术，不断学习新技术，新技术迅速淘汰，又转而去学习更新的技术。但其实，如果深入研究这些新技术，就会发现，它们的不同之处其实只存在于表层，例如各种各样的大前端跨平台开发框架，它们的底层技术其实都是一样的，只是提供了不同的封装方式 。因此，多多关注基础知识和底层的技术 ，能帮助我们走出「不断学习新技术」的死循环。</p>
<p>随着思维和关注点的转变，我们的长期能力也能得到增强，职业发展的天花板也能得到提高。</p>
<p>之后，我打算总结一些学习数据结构和算法当中的知识要点总结在博客里。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一个小程序和第一笔赞赏]]></title>
        <id>https://blog.fanbin.dev/post/OhsLHjLan</id>
        <link href="https://blog.fanbin.dev/post/OhsLHjLan">
        </link>
        <updated>2018-03-28T01:55:35.000Z</updated>
        <summary type="html"><![CDATA[<p>上一个农历年的年底，对小程序开发产生了兴趣，且正好看到「知晓云」这个服务可以在有限条件内免费使用，于是就开始利用业余时间开发起了一个小程序「藏书助手」。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一个农历年的年底，对小程序开发产生了兴趣，且正好看到「知晓云」这个服务可以在有限条件内免费使用，于是就开始利用业余时间开发起了一个小程序「藏书助手」。</p>
<!-- more -->
<p>可以在微信小程序搜索「藏书助手」找到它。</p>
<h2 id="藏书助手">藏书助手</h2>
<p>「藏书助手」是一个纯粹的个人项目。之所以这样说，原因有两个，其一，开发这个项目是为了我满足自己的使用需求，其二，这是为了学习小程序开发用来练手的项目。当开发出最初版本的时候，自己试用了一下，感觉还算顺手，而且目前好像没有类似的小程序，就想着看能不能发布上线。</p>
<p>期间还经历了一些插曲。</p>
<p>这个小程序的功能是通过扫描书籍的条形码，获取 ISBN 后查询书籍相关的信息，进行收藏整理。书籍信息需要从一个拥有书籍信息数据的第三方获取。我最先想到的是从聚合数据或者类似的数据接口提供商那里获取数据，但是存在两个问题。第一个问题，小程序的网络请求必须是 HTTPS 请求，提供商如果不支持，那就肯定不能用。第二个问题，这些服务商的接口在请求的时候，需要将一个我申请的密钥作为参数放在请求里，如果在小程序里使用，就只能把这个密钥以明文的方式写在小程序里，这样明显是不安全的。于是就放弃了这个方案。</p>
<p>之后我发现豆瓣的开放 API 支持 HTTPS，而且是开放接口，可以直接通过公开的地址请求，并且不用附带类似密钥的参数，能请求到的数据也相当完整，于是，就使用了豆瓣的接口。</p>
<p>问题又来了。虽然，每个小程序都是一个独立的，但是，所有的小程序发出去的 HTTPS 请求的 Referer 都是一样的。这样就导致一个问题，如果有一百个小程序在使用豆瓣的数据接口，豆瓣会把这些小程序发出的请求都识别为同一个来源的请求，当请求量很大时（这种情况下，请求量必然会很大），豆瓣就会启动防护，导致小程序没办法使用豆瓣的接口。就在我打算将「藏书助手」提交审核的前一两天，这种情况发生了，而且，看小程序的开发者社区，很多人都遇到了这个问题。</p>
<p>得想别的办法了。</p>
<p>除了豆瓣，没有这样的数据接口了，而且，读取数据的代码都是按照豆瓣给的数据的结构写的，我得想个办法，从别的地方——而不是小程序内——请求豆瓣的数据。最次的办法肯定是搭服务器，转发请求，但是还有没有别的办法呢？</p>
<p>我去看了看阿里云的产品列表，有一个“API 网关”服务，然后发现了“函数计算”服务。于是，我想把这两个做一个结合，通过 API 网关，暴露接口服务，然后调用“函数计算”中自定义的函数，从豆瓣读取数据，再返回给调用 API 网关服务的小程序。不过，折腾了两天，没把这个事情搞定，于是就放弃了。</p>
<p>最后只能用最笨的办法，搭服务器，转发请求。根据小程序后台的要求，所有在小程序中请求数据的网址，都需要在小程序后台配置，且必须是已经备案的站点地址。至此，本来是抱着玩一玩的心态，结果最后来了一个全家桶：购买服务器和域名、走备案程序、配置服务器转发请求。其余的都好说，备案程序走了大半个月。</p>
<p>在农历年之前提交发布上线的计划，也拖到了年后。中间还因为审核不通过被拒了一次，不过，很快就修改了，顺利上线了。</p>
<h2 id="知晓云">知晓云</h2>
<p>决定我开发「藏书助手」小程序的，还有另外一个因素。当时只是为了练手，并没有打算有什么投入，当然包括搭建服务器。因此，「知晓云」的免费个人开发者套餐为我开发「藏书助手」降低了门槛。</p>
<p>知晓云是一个面向小程序的 BaaS 服务，提供了在线数据库、富文本内容、文件的管理，以及用于小程序的 JSSDK，可以免去服务端开发，专注于小程序前端。</p>
<p>只需要在知晓云的后台，新建小程序，并配置好相关的信息，再将它提供的安全网址配置到小程序的后台，就可以开始了。我主要用到了数据库服务，自己设计好数据库接口，就可以在小程序开发工具里，调用知晓云 JSSDK 提供的工具来对数据进行操作了，非常方便。</p>
<p>顺便做个广告，通过我的邀请注册知晓云，可以获得一些优惠：</p>
<p><a href="https://cloud.minapp.com/?invitation=qcrmoj">点这里</a></p>
<h2 id="小程序">小程序</h2>
<p>该说说小程序本身了。</p>
<p>当张小龙第一次提及「应用号」（小程序最开始打算叫这个名字）的时候，给我的感觉就像微信刚刚推出公众号时一样。这两者都是这样一种优秀的产品：它被推出之前，没人做类似的产品，但是它一面世，人们都觉得这是了不起的产品。</p>
<p>小程序兼具原生应用的流畅度和 Web 应用的轻量级，为移动端应用程序提供了新的可能性。对用户来说，小程序无需安装和卸载，无处不在、用完即走；开发者来说，开发工具简单易用，且很容易上手；对各个服务商来说，微信大量的用户、社交关系、完善的支付体系都为各种各样的服务提供了极大的便利。</p>
<p>我从自己开发「藏书助手」的过程中感觉到，这是一个及其低门槛的事情，未来必然会有大量具有想象力的小程序出现。</p>
<h2 id="第一笔赞赏">第一笔赞赏</h2>
<p>今天早上上班刚到公司，看到微信提示我收到了一笔赞赏，赞赏的留言内容是：非常喜欢你的藏书助手小程序。</p>
<p>当时心想，我的小程序里没有放赞赏码，怎么就收到赞赏了呢？后来发现，是一个微信网友在我微信公众号里看到了我关联的小程序，然后，通过我最新发表的文章的赞赏码，给我赞赏了两块钱。</p>
<p>虽然只是两块钱，但是对我是极大的激励，这是我第一次收到陌生人的赞赏。赞赏代表认可，陌生人的认可才是真的认可。</p>
<p>被认可，很开心。</p>
<h2 id="再说藏书助手">再说「藏书助手」</h2>
<p>一开始，开发这个小程序的时候，只想着开发一个很简单的功能，刚刚够用即可，以至于主界面上只有一个按钮。得益于微信的渠道，藏书助手每天都会有几个新用户来访问，大部分进来看看就走了，目前的数据看，有一百来个用户，大部分只打开过一次。</p>
<p>不过，这也给我带来了收获。在小程序后台的数据中，我能看到，点开我开发的小程序的人来自全国各地，用着各式各样的手机，他们通过藏书助手，扫描了各式各样的书，让我知道我的圈子之外的人们，在学习些什么东西。很奇妙。</p>
<p>虽然只是一个业余时间的练手项目，我想，还是应该不断把它完善一下。毕竟，这个世界上有很多爱读书的人，他们坐在自己的书桌前，享受自己的宁静，也不打扰旁人，我希望我和这些人能通过某种东西建立连接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理性派的礼物]]></title>
        <id>https://blog.fanbin.dev/post/xTJsTjgUD</id>
        <link href="https://blog.fanbin.dev/post/xTJsTjgUD">
        </link>
        <updated>2018-03-16T02:08:21.000Z</updated>
        <summary type="html"><![CDATA[<p>前段时间读了桥水基金的创始人瑞·达利欧的《原则》这本书，不得不说，这正是我一直想读的一本真实世界的游戏攻略，作者在书里分享了自己 40 多年的生活和工作原则，这些可执行的原则浓缩了他的智慧和哲学，作者认为，正是这些原则使他获得了今天的成就。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前段时间读了桥水基金的创始人瑞·达利欧的《原则》这本书，不得不说，这正是我一直想读的一本真实世界的游戏攻略，作者在书里分享了自己 40 多年的生活和工作原则，这些可执行的原则浓缩了他的智慧和哲学，作者认为，正是这些原则使他获得了今天的成就。</p>
<!-- more -->
<blockquote>
<p>我一生中学到的最重要的东西是一种以原则为基础的生活方式，是它帮助我发现真相是什么，并据此如何行动。——瑞·达利欧</p>
</blockquote>
<p>瑞·达利欧被称为「投资界的乔布斯」。他打算写两本书来分享自己的原则，第一本分享自己在生活和工作中的原则，第二本则关注经济和投资领域。所以，目前出版的这本，准确的书名应该是《原则：生活和工作》，英文原版书名叫《Principles: Life and Work》。</p>
<h2 id="瑞达利欧">瑞·达利欧</h2>
<p>瑞·达利欧在我眼里绝对是个理性派实干家，他依靠原则和算法管理投资，也一样用它们管理公司和员工。他极度相信原则，并严格执行，他不但自己执行，而且要求公司里所有的员工都严格贯彻，公司在他眼里就像一个依照他的严密逻辑稳定运行的机器。</p>
<p>但他并不是一个独裁者或者「邪教头子」。他提倡人们保持理性和开放的心态解决生活中的问题，并且在工作当中保持极度的真实和透明。理性、开放、透明和「优秀想法至上」这些原则，在读完他的书之后，让人印象深刻。</p>
<h2 id="达成目标的方法">达成目标的方法</h2>
<p>作者在书中介绍的最重要的原则之一，就是「达成目标的五个步骤」。这五个步骤分别是：</p>
<ul>
<li>有明确的目标</li>
<li>找到阻碍你实现这些目标的问题，并且不容忍问题</li>
<li>准确诊断问题，找到问题的根源</li>
<li>规划可以解决问题的方案</li>
<li>做一切必要的事来践行这些方案，实现成果</li>
</ul>
<p>这几个简单步骤中，其实蕴含了很多智慧，如果在真实世界中，这些步骤难以顺利地执行，那一定是缺少这些智慧。比如，设定目标的时候不应该想着自己如何实现，诊断问题的时候不要想着该如何解决，这些都会导致最终问题得不到真正的解决。</p>
<h3 id="找到自己的目标">找到自己的目标</h3>
<p>我们在给自己设定目标的时候，常常会将它与欲望混淆。比如，我想减肥，同时我也特别想吃油腻的食物。这里的「减肥」就是目标，而「想吃油腻的食物」就是欲望。合理的目标是真正想要的东西，而欲望常常会阻止目标的实现。真实世界中识别目标和欲望往往比这个例子要复杂，目标常常隐藏在茫茫的欲望当中，需要用慧眼把它找出来。</p>
<p>关于设定目标，还有一个重要的原则是：不要把那些明知自己能实现的东西最为目标。因为那样的话，对自己要求就太低了。</p>
<h3 id="认识问题">认识问题</h3>
<p>当确立了自己的目标后，就有了前进的方向，这时候就得去发现那些阻碍我们达成目标的因素。这些因素往往来源于我们自身的弱点。那怎么发现它们呢？</p>
<p>达利欧说，人最大的弱点，就是主观行事。在我看来，「主观行事」这四个字说的就是「不理性」。达里奥把「主观行事」归因于两个障碍，一个是「自我」，一个是「盲点」，对于这两个障碍，我同样有自己的理解，「自我」就是不能理性客观地看待自己，「盲点」就是不能理性客观地看待外在环境。</p>
<p>一个人的「自我」这个特性，往往表现为无法接受自己的感情受到伤害，这种人在面对自己弱点的时候多少有点自卑。比如，有些人往往不能接受别人当面调侃自己的弱点，甚至自己私下里都会刻意避免去想。其实，认识到自己的弱点，并不意味这被打败，相反，这是克服它的第一步。让理性而不是自我占上风，这是客观看待自己的前提条件。</p>
<p>其次，只认识自我其实还不够，我们还需要消除自己的盲点，理性地认识认识客观世界。人和人之间看问题的角度大不相同，大家的思维方式也差异巨大，想要消除自己的盲点，就需要我们保持开放的心态，而不是固执己见。站在更高的层面上看事物，总能看得更加清除全面。</p>
<p>消除了这两个障碍，才能真正认识到自己的问题，不至于得出错误的判断的同时还听不进去别人的意见。</p>
<h3 id="诊断问题">诊断问题</h3>
<p>诊断就是要找到问题背后的根本原因，达里奥说，为此你必须区分症状和疾病本身。症状就好比一个人头疼，而疾病本身指的是这个人为什么头疼，可能是因为感冒了，也可能是因为别的什么原因。为了找到疾病本身，我们需要一层一层地去问题背后寻找。</p>
<p>把症状当成疾病本身是一个常常发生在很多人身上的错误，为此，我们同样需要保持开放和理性的心态，观察问题，发现背后的根本原因。</p>
<h3 id="规划和执行方案">规划和执行方案</h3>
<p>达里欧认为，草拟一个行动方案是必不可少的。这也是大多数理性派们做事的风格：制定完美的计划，然后严格执行。</p>
<p>很多书籍都会教人们如何规划自己的行动，然后执行。但也有很多人和我一样，行动力完全被思想上的完美主义所裹挟。什么是思想上的完美主义呢？就是凡事总想要做出完美的规划，然后再去按照规划严格执行。但其实完美的行动规划是不存在的，这样只会让我们成为行动上的矮子。</p>
<p>因此，我认为，理性派们更应该在方案规划上保持克制，把心思放在如何提高自己的行动力上。《自控力》这本书中就说过，计划本身如果花费太多时间，就不会行动了。因为很多人做完计划，感觉已经把这件事干完了，热情已经消耗完了，等真正执行的时候反而没有什么热情了。</p>
<h2 id="决策的最佳模式">决策的最佳模式</h2>
<p>这本书中另一个极其重要的原则叫作「创意择优」。什么是创意择优呢？这是一个在有效权衡不同人所提出观点的可信度的同时，还能让每个人都觉得过程明显公平的决策体系。</p>
<p>达里欧说：一个组织想要成功，不是看创始人有多牛，也不是看手上有多少资源，而是看这个企业能不能奉行创意择优的原则。</p>
<p>可见这一决策体系对达利欧思想原则的重要性。当然，要让这样的体系发挥它的作用，需要一些前提。</p>
<h3 id="极度求真和极度透明">极度求真和极度透明</h3>
<p>创意择优的第一步，是每个人都开诚布公地亮出观点。</p>
<p>作者在书中介绍了一个例子。又一次，达利欧本人要在一个例会讲话，会议本来打算是要讨论公司文化，但是达利欧的讲话大部分时间都花在了讲交易策略上，最后有关公司文化的只讲了十分钟。会议结束后，他收到了一个参会员工的邮件，邮件内容是：</p>
<blockquote>
<p>Ray，你今天在会上的表现，我给你的打分是 D-。之前我们已经说好了会议要讨论文化的事情，可是你显然没有做好这方面的准备，所以你就讲交易策略，内容毫无新意，还讲了 62 分钟 —— 我都给你掐表了。你因为自己没准备好而浪费了大家的时间。</p>
</blockquote>
<p>在达利欧的公司内部，已经直言不讳到了这个程度。不过，这样也有副作用：新来的人都受不了。这些人要么需要一个很长的磨合期，要么过不了多久就走了。</p>
<p>达利欧在书中引用了哈佛大学发展心理学家鲍勃·基根的一句话：</p>
<blockquote>
<p>人在公司其实在做两种工作：一种是他实际正在干的事儿，一种是她做给别人看、希望别人以为他正在做的事儿。</p>
</blockquote>
<p>达利欧希望他所有的员工都只需要做第一种事儿，你不但不用在别人面前假装，该干什么就干什么，而且，也不需要猜别人在干什么。</p>
<h3 id="可信度加权">可信度加权</h3>
<p>大家都开诚布公地亮出了自己的观点，然后，听谁的呢？让每个人都解释自己的观点，然后在讨论，这太浪费时间了。在桥水，每个人，在每个领域，都有一个「可信度」。谁的可信度高，就更倾向于听谁的。</p>
<p>那可信度怎么来呢？第一，如果一个人在当前讨论问题的领域有至少三次成功的经验，那他的可信度就更高。第二，如果这个人能围绕自己的观点，阐述其中的逻辑和因果，那就更好了。</p>
<p>根据每个人的观点和可信度加权进行统计，就能得出最优的结果。</p>
<h2 id="总结">总结</h2>
<p>其实读这本书，还有一个印象深刻的收获，就是学会怎样制定自己的原则，关于这个，之后再单独写吧。</p>
<p>这本书的结构极其清晰，其实就是一个填充了丰富内容的大纲，或者说是一个条理的思维导图，以至于它可以作为一本工具书来用，就是我开头说的「真实世界的游戏攻略」，当遇到一件类似的事情，迷茫或不知所措的时候，可以拿出来看一看。</p>
<p>对我——一个死理性派——来说，这本书仿佛就是一件礼物，在我需要的时候被送到了我手里。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解 Javascript 中变量的作用域]]></title>
        <id>https://blog.fanbin.dev/post/1I45UlWRI</id>
        <link href="https://blog.fanbin.dev/post/1I45UlWRI">
        </link>
        <updated>2015-07-05T02:53:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Javascript 这门语言与其他的大部分语言相比，有很多特殊性，这是很多人喜欢它或者讨厌它的原因。其中变量的作用域问题，对很多初学者来说就是一个又一个「坑」。</p>
<p>变量的作用域在编程技能中算是一个基本概念，而在 Javascript 中，这一基本概念往往挑战者初学者的常识。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Javascript 这门语言与其他的大部分语言相比，有很多特殊性，这是很多人喜欢它或者讨厌它的原因。其中变量的作用域问题，对很多初学者来说就是一个又一个「坑」。</p>
<p>变量的作用域在编程技能中算是一个基本概念，而在 Javascript 中，这一基本概念往往挑战者初学者的常识。</p>
<!-- more -->
<h3 id="基本的变量作用域">基本的变量作用域</h3>
<p>先上例子：</p>
<pre><code class="language-javascript">var scope = 'global';
function checkScope(){
    var scope = 'local';
    console.log(scope); // local
}
checkScope();
console.log(scope); // global
</code></pre>
<p>上面的例子中，声明了全局变量 <code>scope</code> 和函数体内的局部变量 <code>scope</code>。在函数体内部，局部变量的优先级比通明的全局变量要高，如果一个局部变量的名字与一个全局变量相同，那么，在<strong>声明局部变量的函数体范围内</strong>，局部变量将覆盖同名的全局变量。</p>
<p>下面再看一个例子：</p>
<pre><code class="language-javascript">scope = 'global';
function checkScope(){
    scope = 'local'; 
    console.log(scope); // local
    myScope = 'local';
    console.log(myScope); // local
}
checkScope();
console.log(scope); // local
console.log(myScope); // local
</code></pre>
<p>对于初学者来说，可能会有两个疑问：为什么在函数体外，<code>scope</code> 的值也变成了 <code>local</code> ？为什么在函数体外可以访问 <code>myScope</code> 变量？</p>
<p>这两个问题都源于一个特性。在全局作用域中声明变量可以省略 <code>var</code> 关键字，但是如果在函数体内声明变量时不使用 <code>var</code> 关键字，就会发生上面的现象。首先，函数体内的第一行语句，把全局变量中的 <code>scope</code> 变量的值改变了。而在声明 <code>myScope</code> 变量时，由于没有使用 <code>var</code> 关键字，Javascript 就会在全局范围内声明这个变量。因此，在声明局部变量时使用 <code>var</code> 关键字是个很好的习惯。</p>
<h3 id="在-javascript-中没有块级作用域一说">在 Javascript 中，没有「块级作用域」一说</h3>
<p>在 C 或者 Java 等语言中，<code>if</code>、<code>for</code> 等语句块内可以包含自己的局部变量，这些变量的作用域是这些语句的语句块，而在 Javascript 中，不存在「块级作用域」的说法。</p>
<p>看下面的例子：</p>
<pre><code class="language-javascript">function checkScope(obj){
    var i = 0;
    if (typeof obj == 'object') {
        var j = 0;
        for (var k = 0; k &lt; 10; k++) {
            console.log(k);
        }
        console.log(k);
    }
    console.log(j);
}
checkScope(new Object());
</code></pre>
<p>在上面的例子中，每一条控制台输出语句都能输出正确的值，这是因为，由于 Javascript 中不存在块级作用域，因此，<strong>函数中声明的所有变量，无论是在哪里声明的，在整个函数中它们都是有定义的</strong>。</p>
<p>如果要更加强调上文中 <strong><code>函数中声明的所有变量，无论是在哪里声明的，在整个函数中它们都是有定义的</code></strong> 这句话，那么还可以在后面跟一句话：<strong>函数中声明的所有变量，无论是在哪里声明的，在整个函数中它们都是有定义的，即使是在声明之前</strong>。对于这句话，有个经典的困扰初学者的「坑」。</p>
<pre><code class="language-javascript">var a = 2;
function test(){
    console.log(a);
    var a = 10;
}
test();
</code></pre>
<p>上面的例子中，控制台输出变量 <code>a</code> 的值为 <code>undefined</code>，既不是全局变量 <code>a</code> 的值 <code>2</code>,也不是局部变量 <code>a</code> 的值 <code>10</code>。首先，<strong>局部变量在整个函数体内都是有定义的</strong>，因此，局部变量 <code>a</code> 会在函数体内覆盖全局变量 <code>a</code>，而在函数体内，<strong>在 <code>var</code> 语句之前，它是不会被初始化的</strong>。如果要读取一个未被初始化的变量，将会得到一个默认值 <code>undefined</code>。</p>
<p>所以，上面示例中的代码与下面的代码时等价的：</p>
<pre><code class="language-javascript">var a = 2;
function test(){
    var a;
    console.log(a);
    a = 10;
}
test();
</code></pre>
<p>可见，<strong>把所有的函数声明集合起来放在函数的开头是个良好的习惯</strong>。</p>
<h3 id="变量的真相">变量的真相</h3>
<p>可能很多人已经注意到，在 Javascript 当中，一个变量与一个对象的一个属性，有很多相似的地方，实际上，它们并没有什么本质区别。<strong>在 Javascript 中，任何变量都是某个特定对象的属性</strong>。</p>
<p>全局变量都是全局对象的属性。在 Javascript 解释器开始运行且没有执行 Javascript 代码之前，会有一个「全局对象」被创建，然后 Javascript 解释器会给它与定义一些属性，这些属性就是我们在 Javascript 代码中可以直接使用的内置的变量和方法。之后，每当我们定义一个全局变量，实际上是给全局对象定义了一个属性。</p>
<p>在客户端的 Javascript 当中，这个全局变量就是 <code>Window</code> 对象，它有一个指向自己的属性 <code>window</code> ，这就是我们常用的全局变量。</p>
<p>对于函数的局部变量，则是在函数开始执行时，会有一个对应的「调用对象」被创建，函数的局部变量都作为它的属性而存储。这样可以防止局部变量覆盖全局变量。</p>
<h3 id="作用域链">作用域链</h3>
<p>如果要深入理解 Javascript 中变量的作用域，那就必须拿出「作用域链」这个终极武器。</p>
<p>首先要理解的一个名词就是「执行环境」，每当 Javascript 执行时，都会有一个对应的执行环境被创建，这个执行环境中很重要的一部分就是函数的调用对象（前面说过，调用对象是用来存储相应函数的局部变量的对象），每一个 Javascript 方法都是在自己独有的执行环境中运行的。简而言之，函数的执行环境包含了调用对象，调用对象的属性就是函数的局部变量，每个函数就是在这样的执行环境中执行，而在函数之外的代码，也在一个执行环境中，这个执行环境包含了全局变量。</p>
<p>在 Javascript 的执行环境中，还有一个与之对应的「作用域链」，它是一个由对象组成的列表或链。</p>
<p>当 Javascript 代码需要查询一个变量 <code>x</code> 的时候，会有一个被称为「变量名解析」的过程。它会首先检查作用域链的第一个对象，如果这个对象包含名为 <code>x</code> 的属性，那么就采用这个属性的值，否则，会继续检查第二个对象，依此类推。当检查到最后一个对象的时候仍然没有相应的属性，则这个变量会被认定为是「未定义」的。</p>
<p>在全局的 Javascript 执行环境中，作用域链中只包含一个对象，就是全局对象。而在函数的执行环境中，则同时包含函数的调用对象。由于 Javascript 的函数是可以嵌套的，因此每个函数执行环境的作用域链可能包含不同数目个对象，一个非嵌套的函数的执行环境中，作用域链包含了这个函数的调用对象和全局对象，而在嵌套的函数的执行环境中，作用域链包含了嵌套的每一层函数的调用对象以及全局变量。</p>
<p>我们可以用一个图来直观地解释作用域链和变量名解析的过程：</p>
<figure data-type="image" tabindex="1"><img src="http://blog-fanbin-ink.img.fanbin.ink/post/1I45UlWRI/1.png" alt="Javascript 作用域链he变量名解析"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电子化笔记心得分享]]></title>
        <id>https://blog.fanbin.dev/post/6A-xY4FpJ</id>
        <link href="https://blog.fanbin.dev/post/6A-xY4FpJ">
        </link>
        <updated>2014-01-27T03:10:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="所谓笔记">所谓「笔记」</h2>
<p>俗话说，“好记性不如烂笔头”，我们在日常生活和学习的过程中，总会在思考的同时伴随着要记住一些东西，有些东西有短暂的记忆就好了，比如出门前记得关灯，有些事情，要记住一段时间，比如周末的行程计划，或者两个月后的考试要考察的内容，再比如很多东西需要一直记住，以便随时回忆起来以便思考一些事情。</p>
<p>我们的大脑承担者两个重要的工作——思考和记忆，尽管人与人是有差异的，但是人和人的思考能力都差不多，或者各有所长，总之，个体的思考能力是没办法借助工具显著提高的。但是记忆却不同，有很多东西可以帮助我们记住更多东西，人类从很早的时候，就开始用各种方法去“记住一些事情”。</p>
<p>如果说语言的出现是为了方便人们交流，那么文字便是早期人类记录事物的高级工具（现在可以用来记录的载体就很多了：照片、录音，甚至是视频），但还是文字更能让人随手记录自己的灵感或者见闻，甚至是情感。</p>
<p>所以我认为，每个人都应该有记录的习惯。记录灵感，可以让自己的奇思妙想不会很快被忘掉；记录见闻，可以让我们能回忆经历过的事情；记录情感，可以让我们回忆过去；记录知识，可以让我们博学；记录花销，可以让我们学会花钱；记录任何关于自己的一点一滴，更是能让自己在回顾总结中认清自己。</p>
<p>可见，「笔记」不是简简单单的记下一件事情那么简单了。</p>
<h2 id="用多元化的记录方式快速收集笔记">用多元化的记录方式快速收集笔记</h2>
<p>如果我们用最原始的方式记笔记，那么收集笔记内容的方法很简单，一支笔，一个本子，把要记的东西写下来，必要时配一些图表，就好了。这是最简单直接信手捏来的记录方式，符合每个人的习惯，不用思考就可以去做。</p>
<p>但是当有了一些电子化的能有效提高效率的笔记工具以后，我们记录笔记的方式就多了起来，比如拍一张照片，录一段声音，或者直接保存一份文件。但是无论如何，在收集笔记的时候，选择一个最顺手最便捷的方式是极其重要的，有时候一个念头在脑海里一闪而过，闪过之后，又要忙别的事情了，如果没有一个特别快捷的办法记下来，可能要么就忘记了，要么自己都懒得记了。总有时候我们会嫌一时的麻烦而放弃记下一些可能很重要的东西，所以便捷多元化的笔记收集途径，就显得尤为重要。</p>
<h4 id="文字记录">文字记录</h4>
<p>这是最简单的收集方式，很多东西都可以很直接地用文字表达。我们更习惯用语言描述事物，而文字是语言的书面形式。用文字记笔记最重要的的是，尽量简洁挑重点，不用注意语言的连贯性或者语法的准确，应该把这些放在笔记的整理和回顾阶段（笔记的回顾和整理，后面细说）。</p>
<h4 id="拍张照片用一秒钟记录眼前的一切">拍张照片，用一秒钟记录眼前的一切</h4>
<p>很多时候，我们需要把自己眼前很短暂的事物或信息记录下来，很显然用文字是很难做到的，这个时候，用照片就很方便，一瞬间就能记录很多信息，甚至有时候，一张照片抵得上千言万语。</p>
<h4 id="图表能用很简单直观的方式表达文字难以表达的内容">图表能用很简单直观的方式表达文字难以表达的内容</h4>
<p>虽然文字几乎能表达一切事物，但是，有时候却不是那么方便和直观，图表就是一个极具效率和直观性的代替文字的记录语言，在合适的场合，使用表格、流程图等方式，可以很方便地记录便于直观阅读的内容。</p>
<h4 id="收集录音">收集录音</h4>
<p>这个最简单粗暴直接，如果你在听讲座、演讲，或者在进行采访，没什么比录音更方便的了。类似的还有录像。</p>
<h4 id="纸质笔记的电子化">纸质笔记的电子化</h4>
<p>虽说笔记的电子化，能带来许多便捷，但是它始终无法代替纸质的笔记，但纸质笔记不便于携带、查阅，并且难以保管，所以将纸质笔记电子化是一个很好的收藏方式。最好的方法，当然是用扫描仪扫瞄进电脑里，然后保存好，但是扫描仪又不是很方便，所以最便捷的方式是拍照。用拍照的方式保存纸质笔记，就很方便，可以随手操作。更好的是，比如Evernote笔记软件的拍照保存，就有专门为记录纸质笔记优化的功能，能将一张照片上的纸质笔记很真实地还原，让它在电脑上看起来更像真实的白纸黑字。</p>
<h4 id="总之">总之</h4>
<p>只要把“笔记”的概念立即地宽泛一点，收集笔记的方式就还有很多，比如浏览器书签，微博收藏夹等，但最终一定记得把这些东西收归一处，便于整理和查找。</p>
<h2 id="按一定的规则整理以使笔记更加条理">按一定的规则整理以使笔记更加条理</h2>
<p>笔记当然不能只是收集完就结束了，许多人把记录当作记住，这是一个很大的误区，这种错误只会导致我们为收集内容所花费的时间白白浪费。笔记最重要的价值当然是用来查阅的，它是一本属于自己的百科全书，一本书应该有自己合理的内容关系架构，因此，如何整理我们收集来的笔记显得尤为重要。</p>
<p>最简单粗暴直接的方式就是分笔记本（或者文件夹）分类整理笔记，这是大多数人习惯的方式。我们通常把歌曲放到一个叫 music 的文件夹里，把相机里导出的照片放到 photos 文件夹里，对于一些内容简单的笔记来说，这是最合适的方式。但事实往往不是这样的，比如会有这样一种情况，几个朋友一起去旅行，积攒了好多视频和照片或者还有日记回来，重点来了，我是把照片、视频、日记分别放到他们该呆着的地方呢，还是把它们一起放到一个叫旅行的文件夹里？貌似都合适，最好的方式是再拷贝，按两种归档方式分别保存一份，但是这要消耗两倍的存储空间，如果你能想出更多的分类方式，那就成了悲剧。</p>
<p>至此，标签化管理的方式在最合适的时候登场了。先解释，标签化管理方式摒弃了文件夹管理方式的恶习，每个文件或每条笔记可以搭上多种标签，比如有一条笔记被打上了日记和旅行两个标签，这样不管你是找自己的日记，还是找和旅行相关的内容，它都会被找到。标签更加包容，它不会独自占有一个文件，也不会被唯一的文件占有，而且标签之间也没有绝对的从属关系，它是散列式的。好比一个老师在班里只需要问一个问题就可以轻松的找出所有姓李的同学或者所有家乡在山西的同学，而不需要先按姓氏或者籍贯分班，再找。这种先进的文件管理方式被广泛地应用于各种信息管理软件以及 Mac 电脑的操作系统。不过这种比较开放的管理方式对一个人来说是否能够提高效率，还要依靠这个人怎么使用它，怎么合理地设计标签。不过习惯了以后，自然会有一套自己的管理逻辑。</p>
<h2 id="快速找到想要的信息">快速找到想要的信息</h2>
<p>之所以在讲信息检索之前先讲分类整理，是因为所有的内容管理软件里都不会内置专用的 Google 帮你将你最需要的内容拿到你面前，即使是强大的 Google，也需要在不断改进搜索算法的同时不断对收集到的信息进行整理。</p>
<p>快速找到笔记也是一门技术活，即使是在手写笔记是唯一记录方式的年代，人们也发明了各种寻找重要信息的便捷方式，比如：折角，贴标签纸，或者是各种各样方便信息检索的形式纸质笔记本被发明出来。当自己的信息记录多到一定程度的时候，快速查找信息的重要性和难度会自然而然地提高。其实利用研究 Google 检索信息的方法来提高自己检索信息的能力是完全没头脑的，因为 Google 的强大之处在于利用软件技术和身后强大的数据进行不断地学习和反思，这本来就是人脑的运转模式。</p>
<p>所以，查找信息依然是最普通的按照路径、标签、关键词等信息查找。路径查找用于文件夹的管理方式，标签查找用于标签的管理方式，这些都取决于对笔记的整理是否合理。而关键词查找信息就是一门大学问了，别看你整天用 Google 能随随便便搜索出自己想要的内容，这其实是靠强大的 Google 背后无穷的力量来实现的，全球每天几亿人用G oogle ，每个人每天又不知道会搜索多少关键词，Google 通过他们搜索的关键词和点击行为，不断学习和完善，来通过你的关键词来判断你真正想要的东西，这背后的原理相当复杂和庞大。但是我们自己的笔记就不同了，处于个人信息管理的局限性，再高级的信息管理系统也不会了解你什么时候想要什么，这时就需要自己合理地提取关键词，然后再结合路径和标签的方法来查找。其中学问，全靠个人摸索。</p>
<h2 id="定期回顾让信息存活">定期回顾，让信息存活</h2>
<p>什么？我把东西记下来，用的时候查不就行了么？用得着定期回顾么？这个问题分两点回答：其实是前面所说，记录不等于记忆，自己的笔记里记录的当然都是自己想要知道、想要学会、想要记住的东西，当然要定期回顾，不能让它「死」在那里；其二，如果不会顾，自己都不知道自己记录了哪些东西，那么在笔记中查找东西与 Google 何异，甚至还不如 Google。</p>
<p>笔记的形式多样，我们的浏览器收藏夹、微博收藏夹、手机相册、录音、日记等等都可能成为我们笔记的一分子，前面提到，为了查阅方便，自己的笔记一定要收归一处，而每次整理笔记的时候，就是一个回顾的好时机，我们可以回顾一下自己记录下来想要学习的东西和过去经历的事情。除此之外，定期地回顾笔记也是一个好习惯，这其中的好处不必细说，你一定深有体会。</p>
<h2 id="分享是一种精神">分享是一种精神</h2>
<p>分享的意义何在？就好比一个人独自吃一盘菜跟八个人一起拼一桌菜的区别，相信大部分正常人都喜欢后者。而将自己的知识分享则百利而无一害。交换苹果，你我都还是只有一个苹果，交换想法，我们每个人就多了一个想法。这个道理相信大家都懂。分享自己的知识、感悟就好比相互交流学习，这也是最能让人进步的学习方法之一。</p>
<p>在个人信息电子化的时代，信息分享变得更加简单了，何不去分享来收获更多呢。</p>
<h2 id="如何打造完整的个人知识仓库">如何打造完整的个人知识仓库</h2>
<p>这才是重头戏。</p>
<p>如果你喜欢用电子化的方式整理自己的笔记，甚至是所有信息，那么你一定需要有一定的能力和方法构建自己的知识仓库，让自己在手机、整理、检索和分享自己的个人信息形成一个完整的工作流（workflow），这项工作有个专有的名字，叫做个人信息管理（PIM）。</p>
<p>对于收集来说，应该尽量采用多元化的方式，应该尽量缩短信息手机的过程，这样有利于收集的积极性，一件可以随手做的事情，总是不会懒得去做的。</p>
<p>分析和整理阶段极其重要，首先要把收集到的东西统一归纳，再用自己习惯的方式（前面介绍过的文件夹和标签管理，以及更多自己探索出来的整理方法）将这些信息整理，形成一个条理的信息仓库。</p>
<p>定期地回顾同样重要，回顾不仅是巩固的过程，也是完善的过程，好比把收集来的信息和笔记用自己理解的方式整理出来，这样更利于自己以后的查阅。</p>
<p>至此，随着信息不断收集、整理，信息量越来越大，逐渐就会形成一个自己的只是仓库，包含着所有自己收集和记录过的信息。如果想要它价值倍增，与人分享是最佳的途径，分享包括与别人交流学习、发表文章、甚至是将自己整理的成体系的内容出版成一本书，就是这么简单。</p>
]]></content>
    </entry>
</feed>